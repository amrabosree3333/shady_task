# Blind Signature
> Node.js implementation of Chaum's blind signatures

This is based on the JSBN library for BigNumbers. It doesn't handle the
generation of RSA keys but expects them in the normal format of:

```typescript
export interface PublicRSAKey {
  n: BigInteger,
  e: number
}

export interface PrivateRSAKey extends PublicRSAKey {
  p: BigInteger
  q: BigInteger
  d: BigInteger
  dmp1: BigInteger
  dmq1: BigInteger
  coeff: BigInteger
}
```

The RSA key you use for this library should be used **only** for these blind
signatures! If you use it for encryption or other signatures too, it opens up
serious vulnerabilities. This is a pretty low level blind signatures library so
make sure you understand the underlying cryptography and the potential
vulnerabilities.

Messages are hashed before they are signed. For maximum safety, a hash function
is used with the same bitlength as the RSA key's modulus. We accomplish this by
hmac'ing the message with `1`, then `2`, and so on, concatenating the outputs
together until we get the desired length.

## Usage Example

```typescript
import {
  hashAndBlindMessage,
  signBlindedMessageHash,
  unblindSignature,
  verifySignature
} from 'blind-signature'

// this happens on client
const publicKey = // ...
const message = 'hello world'
const { blindedMessageHash, blindingFactor } =
  hashAndBlindMessage(publicKey, message)

// this happens on server/signer
const privateKey = // ...
const blindSignature =
  signBlindedMessageHash(privateKey, blindedMessageHash)

// this happens on client
const signature =
  unblindSignature(publicKey, blindSignature, blindingFactor)

// verification can be done by the signer or client at any time
const isVerified = verifySignature(publicKey, message, signature)
```

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const jsbn_1 = require("jsbn");
function getBlindingFactor(n) {
    let blindingFactor;
    const bytesLength = Buffer.from(n.toString(16), 'hex').length;
    do {
        const hexBytes = crypto_1.randomBytes(bytesLength).toString('hex');
        blindingFactor = new jsbn_1.BigInteger(hexBytes, 16);
        // TODO: maybe change this to constant time compare? could leak small
        // amount about timingAttackBlinding
    } while (blindingFactor.compareTo(n) >= 0 ||
        blindingFactor.compareTo(jsbn_1.BigInteger.ONE) <= 0);
    return blindingFactor;
}
exports.getBlindingFactor = getBlindingFactor;
function blindMessageHash(params) {
    const n = params.n;
    const messageHash = new jsbn_1.BigInteger(params.messageHash, 16);
    const blindingFactor = getBlindingFactor(n);
    const blindingFactorE = blindingFactor.modPowInt(params.e, n);
    const blindedMessageHash = blindingFactorE
        .multiply(messageHash)
        .mod(n)
        .toString(16);
    return {
        blindedMessageHash,
        blindingFactor: blindingFactor.toString(16)
    };
}
exports.blindMessageHash = blindMessageHash;
function unblindBlindSignature(params) {
    const n = params.n;
    const blindingFactor = new jsbn_1.BigInteger(params.blindingFactor, 16);
    const blindSignature = new jsbn_1.BigInteger(params.blindSignature, 16);
    const blindingFactorInverse = blindingFactor.modInverse(n);
    const unblindedSignature = blindSignature
        .multiply(blindingFactorInverse)
        .mod(n)
        .toString(16);
    return unblindedSignature;
}
exports.unblindBlindSignature = unblindBlindSignature;
